# Errors and exceptions

Like many things in the world of PHP, error handling is divided into the old way of doing things, and the new way of doing things. They don't always work terribly well with each other, but knowing (at least on a high level) how they work will help with understanding how the PHP agent operates.

## Errors

PHP has had support for errors since its earliest days. An error, in PHP parlance, contains a message, a level (common levels include `E_ERROR`, `E_WARNING`, and `E_NOTICE`), the execution stack at the time the error was triggered, and an optional code.

Most errors in PHP are generated by PHP itself, but it's also possible to trigger an error with the aptly named [`trigger_error()`](https://secure.php.net/trigger_error) function.

By default, PHP handles errors according to its configuration: the `error_reporting` setting is a bitfield that describes which error levels should be handled, and the `display_errors` and `log_errors` settings allow for errors to either be output (useful in development; terrible in production) or logged to a file or syslog. Some errors are considered to be fatal, in which case execution will terminate as soon as the error is displayed or logged; others are warnings or notices, in which case execution continues normally.

PHP's error handling can also be customised using the [`set_error_handler()`](https://secure.php.net/set_error_handler) function, which allows a function to be provided that will be invoked each time an error occurs. This allows for more fine-grained logging or handling, but doesn't allow for an exception-style change to the execution flow: the only way the handler can change the execution flow is by executing whatever functions it wants called and then calling [`exit()`](https://secure.php.net/exit) to terminate the script.

All in all, errors are a rather blunt instrument, but still the primary way logic errors when executing PHP code are reported, especially on PHP 5.

## Exceptions

PHP 5 added support for exceptions. This is implemented using the normal pattern for object-oriented, C-family languages: exception objects<sup id="a0">[0](#f0)</sup> are thrown via a `throw` statement, and caught in `try-catch` blocks: the `catch` blocks are scoped to a particular class. PHP 5.6 also added support for `finally` blocks.

A last resort exception handler can be installed using [`set_exception_handler()`](https://secure.php.net/set_exception_handler), which is conceptually very similar to `set_error_handler()` above. Most frameworks use this to provide a useful internal error response to the user rather than bubbling the exception details back up to output.

Notably, with very few exceptions<sup id="a1">[1](#f1)</sup>, PHP 5 doesn't use exceptions for standard library functionality. Exceptions are provided for use by "userland" (ie PHP) code, but are not used by PHP itself. This means that defensive code needs to handle both exceptions and errors.

PHP 7 changed this: most internal errors are now represented as exceptions inheriting from the [`Error`](https://secure.php.net/error) class, and can be handled by a normal `try-catch` block.

## Our approach

New Relic's APM product doesn't have the ability to distinguish between errors and exceptions, since no other language is quite this idiotic. As a result, we conflate the two: the PHP agent captures both, and allows separate configuration of both errors and exceptions, but we report them back to APM using the same APM errors mechanism.

## Footnotes

<sup id="f0">0</sup> On PHP 5, exception objects can be an object of any class that inherits from the internal [`Exception`](https://secure.php.net/exception) class. On PHP 7, exception objects need only implement the internal [`Throwable`](https://secure.php.net/throwable) interface, which allows for more customisation. [↩](#a0)

<sup id="f1">1</sup> Sorry. [↩](#a1)